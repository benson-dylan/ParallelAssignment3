# ParallelAssignment3
<h2>Compilation and Execution Instructions</h2>
<p>Run javac BirthdayPresents.java <br>Then run java BirthdayPresents <br>The file "out.txt" will be created after completion and holds the text output of the program. When the program terminates, a console statement noting the runtime will appear to let you know when it is finished.</p>

<h2>Birthday Presents</h2>
<p>To solve this problem I created a concurrent linked list (singularly linked) to act as the "chain" described in the problem. It includes only the functionality required to solve the problem and inserts in numerical order. Items are only removed from the head which is an O(1) operation. To handle the "giftbag" and ensure that all the thank you cards have been written I used synchronized HashSets (shuffled for randomness). The giftbag set was filled with 500000 integers to represent the presents, then one of the three described tasks would occur at random. When a present would be removed from the set it would be added to the linked list, from there it would be removed from the front of the list and added to the card set to symbolize a card being written for that gift. Once the card set reached 500000 all the presents have been accounted for.<br><br>Since the method involves an amount of randomness execution times can vary but average run time was 36 seconds on my machine utilizing Java's PrintWriter class.</p>

<h2>Compilation and Execution Instructions</h2>
<p>Run javac AtmosphereReading.java <br>Then run java AtmosphereReading <br>All output will print to console and a statement noting the runtime will let you know when the program is finished.</p>

<h2>Atmospheric Temperature Reading</h2>
<p>To solve this problem I created two Synchronized ArrayLists, one to represent the temperature readings of all sensors, and the other to represent the statuses of all the sensors. The size of the readings list is determined by the number of readings per report and the number of threads (NUM_READINGS * NUM_THREADS). This allows each thread to write concurrently to the list without having to lock it by using an offset determined by the threadID. While a thread is still writing to the shared readings list, it is considered "busy", a new reading will not be performed until all threads are considered "ready" to avoid writing over the results of the previous hour. Threads that have finished wait in a while loop until all threads are marked as "ready". After all readings for an hour are calculated, a report is generated. The program is run for 24 hours, generating 24 unique reports.<br><br>For 24 hours, my machine completed the program in 180ms on average, at 72 hours the program finished in 400ms on average.</p>

